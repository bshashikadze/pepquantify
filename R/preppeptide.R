#' Extract the necessary information for the peptide data
#' @description This function keeps only the necessary columns that are needed for the next steps. Importantly, dataset will be reduced to a dual comparisons by passing proper group names in the condition1 and condition2.
#'     This is important since MS-EmpiRe in one analysis can quantify dual comparisons only. Also, MS-EmpiRe requires minimum two valid values in EACH condition, so in this step filtering for valid values
#'     is also performed by user defined settings (see also imputation step of the pepquant package)
#' @param data list of two containing peptide and protein group data generated by the read functions of the pepquant package
#' @param condition1 name of the first condition that should be compared (note that order matters for the fold-change direction)
#' @param condition2 name of the second condition that should be compared (note that order matters for the fold-change direction)
#' @param n_condition_1 minimum number of the valid values in the first condition (this value should be at least two, but default pepquant value is three)
#' @param n_condition_2 minimum number of the valid values in the second condition (this value should be at least two, but default pepquant value is three)
#' @param n_element_peptide peptide data is the nth element (usually not necessary to change)
#' @param min_pep minimum number of peptides for each protein
#' @return filtered_data_dual which is the list of 6. This output should always be generated but is only useful if imputation is performed. Also, conditions and peptide file (without imputation) will be written in the designated folder.
#' @import dplyr utils tidyr tibble
#' @importFrom magrittr %>%
#' @export
#'
#' @examples preppeptide(data, condition1, condition2)
preppeptide <- function(data, n_element_peptide = 1, condition1 = "P", condition2 = "wt", n_condition_1 = 3, n_condition_2 = 3, min_pep = 2) {



  # create the sub directory where only the specific comparison will be stored
  # first checks if the file exists if yes it deletes and rewrites, this is crucial in the last step of the
  #  msempire analysis to read the right folder for the right   comparison

  if (file.exists(paste0(condition1, "_vs_", condition2))) {
    unlink(paste0(condition1, "_vs_", condition2), recursive = T)
    dir.create(paste0(condition1, "_vs_", condition2))
  }

  else {dir.create(paste0(condition1, "_vs_", condition2))}


  # read the modified conditions file
  if (file.exists("conditions_modified.txt")) {
    conditions <- read.delim("conditions_modified.txt") }
  else{cat(" conditions_modified.txt file does not exist ")}


  # was conditions files modified?
  stopifnot("the second column in the experimental conditions file seems not modified!" = length(unique(conditions$Condition)) !=
              length(conditions$Bioreplicate))


  # choose the peptide data (this will be crucial if only peptides data will be read without protein groups file)
  if (length(data) >= 2) {

    data <- data[[n_element_peptide]]

  }
  else {data <- data}


  # reduce the entire data to the specific dual comparisons (this is useful when multiple conditions are present. in case of two
  #conditions initial data is not modified)

  data_dual <- data %>%
    tidyr::pivot_longer(names_to = "Bioreplicate", values_to = "Intensity", -c(.data$id, .data$unique_id)) %>%
    dplyr::left_join(conditions) %>%
    dplyr::filter(.data$Condition == condition1 | .data$Condition == condition2)



  # count the valid values per sample
  valid_count <- data_dual %>%
    dplyr::group_by(.data$unique_id, .data$Condition, .data$id) %>%
    dplyr::summarise(n_cond = sum(.data$Intensity > 0, na.rm = TRUE)) %>%
    dplyr::ungroup() %>%
    tidyr::pivot_wider(names_from = "Condition", values_from = "n_cond", c(.data$unique_id, .data$id))



  # this is the matrix which contains only those peptides that contain valid values equal or more than defined in the function
  # no imputation will be performed on this
  # this is still not filtered for minimum peptide (but data_dual_valid_save is) because final filtering will
  # be performed when (if) imputed peptides will be added
  data_dual_valid <- data_dual %>%
    tidyr::pivot_wider(names_from = "Bioreplicate", values_from = "Intensity", c(.data$id, .data$unique_id)) %>%
    dplyr::left_join(valid_count) %>%
    dplyr::group_by(.data$unique_id) %>%
    dplyr::filter(!!as.symbol(condition1) >= n_condition_1 & !!as.symbol(condition2) >= n_condition_2) %>%
    dplyr::ungroup() %>%
    dplyr::select(-all_of(condition1), -all_of(condition2))



  # filter for one peptide and save (this data will be used if imputation will not be performed)
  data_dual_valid_save <- data_dual_valid %>%
    group_by(.data$id) %>%
    mutate(n_pep = n()) %>%
    ungroup() %>%
    dplyr::filter(.data$n_pep >= min_pep) %>%
    dplyr::select(-.data$id)



  # write the results. this will be read by msempire. in case imputation will be performed this file will be overwritten
  write.table(data_dual_valid_save, paste0(condition1, "_vs_", condition2, "/peptidesformsempire.txt"), sep = "\t", row.names = F)



  # this contains entire peptide matrix on which the imputation will be performed
  data_dual_for_imp <- data_dual %>%
    tidyr::pivot_wider(names_from = "Bioreplicate", values_from = "Intensity", c(.data$id, .data$unique_id)) %>%
    dplyr::select(starts_with("Intensity."), .data$unique_id) %>%
    tibble::column_to_rownames("unique_id") %>%
    dplyr::mutate_all(~na_if(., 0)) %>%
    dplyr::mutate_all(., log2)



  # write the conditions file in a designated folder. this conditions will only contain comparisons of interest and will lately be
  # used for the msempire analysis. Letters "A" and "B" are inserted before each condition to freeze the order: important for fold-change direction
  conditions_dual <- conditions %>%
    dplyr::filter(.data$Condition == condition1 | .data$Condition == condition2) %>%
    dplyr::mutate(Condition = case_when(.data$Condition == condition1 ~ paste0("A_", condition1),
                                        TRUE ~ paste0("B_", condition2))) %>%
    write.table(paste0(condition1, "_vs_", condition2, "/conditions_dual.txt"), sep = "\t", row.names = F)



  # save the results (different levels store the information that might be used by other following functions)
  filtered_data_dual      <- list()
  filtered_data_dual[[1]] <- valid_count
  filtered_data_dual[[2]] <- data_dual_for_imp
  filtered_data_dual[[3]] <- data_dual_valid
  filtered_data_dual[[4]] <- c(condition1, condition2)
  filtered_data_dual[[5]] <- c(n_condition_1, n_condition_2)
  filtered_data_dual[[6]] <- min_pep



  # return the data
  return(filtered_data_dual)

  }
